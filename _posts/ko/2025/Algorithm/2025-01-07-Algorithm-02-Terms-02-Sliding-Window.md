---
title: 알고리즘 02 - (용어 02) 슬라이딩 윈도우 (Sliding Window)란
author_profile: true
read_time: true
comments: true
share: true
related: true
categories:
- Algorithm
tags:
- Algorithm
- 
- 
toc: true
toc_sticky: true
toc_label: 목차
description: 알고리즘 문제 - 슬라이딩 윈도우 (Sliding Window)란
article_tag1: Algorithm
article_tag2: 
article_tag3: 
article_section: 
meta_keywords: Algorithm, 
last_modified_at: '2025-01-07 21:00:00 +0800'
---


### **슬라이딩 윈도우 (Sliding Window)란?**


슬라이딩 윈도우는 배열이나 문자열에서 **효율적으로 구간을 탐색하는 기법**으로 매우 유용합니다. 

`슬라이딩 윈도우`는 **배열**이나 **문자열**에서 **연속된 부분 배열** 또는 **부분 문자열**을 효율적으로 계산하는 알고리즘 기법입니다. 윈도우(Window)는 일정한 크기의 **구간**을 의미하며, 이 구간을 **슬라이딩(이동)**시켜가며 필요한 정보를 계산합니다. 

이 기법은 **고정 크기 윈도우**와 **가변 크기 윈도우**로 나눌 수 있습니다.

#### **윈도우(Window)**는 **"부분 구간"**을 의미합니다.  
그렇기 때문에 '창(Window)'과 비슷한 개념으로 이해할 수 있는데, 윈도우는 배열이나 문자열의 특정 부분을 가리키며, **슬라이딩(이동)**하면서 구간을 탐색합니다.

---

### **슬라이딩 윈도우 기법의 핵심 개념**
1. **슬라이딩 윈도우**는 **배열**이나 **문자열**을 일정한 크기나 조건에 맞는 범위로 나누고, 이 범위를 오른쪽으로 이동하면서 필요한 값을 계산하는 방식입니다.
   
2. **윈도우 크기**는 두 가지로 나뉩니다
   - **고정 크기 윈도우**: 구간 크기가 일정하며, 슬라이딩을 할 때 구간 크기는 변하지 않습니다.
   - **가변 크기 윈도우**: 구간 크기가 조건에 따라 달라집니다.

---

### **슬라이딩 윈도우 사용 예시**

#### **1. 고정 크기 윈도우**
구간의 크기가 일정하고, 그 구간을 오른쪽으로 슬라이딩하면서 필요한 계산을 합니다. 가장 자주 사용되는 예시 중 하나는 **부분 배열 합**을 구하는 문제입니다.

#### **예시: 배열의 부분합 구하기**

(문제) 배열 `nums`와 크기 `k`가 주어졌을 때, **길이가 k인 연속된 부분 배열들의 합**을 구하세요.

예: `nums = [1, 2, 3, 4, 5], k = 3`

부분 배열의 합은 `1+2+3 = 6`, `2+3+4 = 9`, `3+4+5 = 12`입니다.

#### **고정 크기 윈도우 코드 예시 (부분합 구하기)**

```python
def max_sum_subarray(nums, k):
    window_sum = sum(nums[:k])  # 초기 윈도우의 합
    max_sum = window_sum

    for i in range(k, len(nums)):
        # 윈도우를 슬라이딩
        window_sum += nums[i] - nums[i - k]
        max_sum = max(max_sum, window_sum)

    return max_sum

# 테스트
nums = [1, 2, 3, 4, 5]
k = 3
print(max_sum_subarray(nums, k))  # 출력: 12
```

##### **작동 과정:**
1. 첫 번째 윈도우는 `[1, 2, 3]`이고 합은 `6`.
2. 두 번째 윈도우는 `[2, 3, 4]`이고 합은 `9`.
3. 세 번째 윈도우는 `[3, 4, 5]`이고 합은 `12`.

---

#### **2. 가변 크기 윈도우**

가변 크기 윈도우는 구간의 크기가 고정되지 않고, 조건에 따라 윈도우의 크기가 늘어나거나 줄어듭니다. 주로 **조건을 만족하는 부분 배열**을 찾을 때 사용됩니다.

#### **예시: 가장 긴 부분 문자열의 길이 (중복 문자가 없는)**

문자열에서 중복되지 않는 가장 긴 부분 문자열의 길이를 구하는 문제입니다. 이 문제는 가변 크기 윈도우로 해결할 수 있습니다.

#### **가변 크기 윈도우 코드 예시 (중복 없는 부분 문자열)**

```python
def longest_substring(s):
    char_set = set()
    left = 0
    max_length = 0

    for right in range(len(s)):
        # 중복이 있으면 왼쪽 포인터를 이동시켜 중복을 제거
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        # 현재 문자 추가
        char_set.add(s[right])
        # 최대 길이 갱신
        max_length = max(max_length, right - left + 1)

    return max_length

# 테스트
s = "abcabcbb"
print(longest_substring(s))  # 출력: 3
```

##### **작동 과정**
1. 첫 번째 문자는 `a`, `b`, `c`를 추가하고, 그 길이는 `3`.
2. 두 번째 `a`가 등장하면 중복이 발생하므로 왼쪽 포인터를 이동하여 `b`, `c`를 제거하고, 새로 추가된 `a`와 함께 길이를 계산합니다.
3. 중복을 없애면서 계속 진행해 최종적으로 가장 긴 부분 문자열의 길이를 찾습니다.

---

### **슬라이딩 윈도우의 장점**
1. **효율성**: 한 번의 탐색으로 문제를 해결하므로 시간 복잡도가 줄어듭니다. 특히 **O(n)**로 해결할 수 있는 문제들이 많습니다.
2. **메모리 절약**: 구간을 계속 갱신하기 때문에 추가적인 메모리 공간을 거의 사용하지 않습니다.

---

### **슬라이딩 윈도우의 단점**

1. **문제의 특성에 맞는 경우에만 유효**: 배열이나 문자열에서 연속된 부분 배열이나 부분 문자열을 처리하는 문제에서 효과적입니다. 그 외의 문제에서는 사용할 수 없습니다.
2. **구간 조작에 주의**: 슬라이딩 윈도우를 구현할 때, 윈도우의 크기나 구간을 올바르게 갱신하는 데 주의해야 합니다.

---

### **슬라이딩 윈도우를 기억하는 법**

1. **"창이 슬라이딩 한다"**는 이미지를 떠올려 보세요. 창을 **좌우로 이동**시키며 구간을 갱신하는 느낌입니다.

2. **"한 번에 전체를 탐색"**하는 방식으로 생각하세요. 구간을 계속 갱신하면서, 매번 전체를 다시 탐색하지 않고, 이전 계산 결과를 바탕으로 효율적으로 진행하는 방식입니다.

---

### **슬라이딩 윈도우 연습 문제**
1. **문제**: 정수 배열에서 합이 `target`이 되는 부분 배열의 개수를 구하세요.
2. **문제**: 문자열에서 **최소 길이의 부분 문자열**을 구하세요. (주어진 문자들을 모두 포함해야 함).

---
